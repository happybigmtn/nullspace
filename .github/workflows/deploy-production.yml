name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      skip_smoke_tests:
        description: 'Skip post-deployment smoke tests'
        required: false
        type: boolean
        default: false
      services:
        description: 'Services to deploy (comma-separated, or "all")'
        required: false
        type: string
        default: 'all'

# Ensure only one production deployment runs at a time
concurrency:
  group: production-deploy
  cancel-in-progress: false

jobs:
  # Pre-deployment validation
  validate:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}
      services: ${{ steps.services.outputs.list }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine image tag
        id: tag
        run: |
          # Use the latest main branch SHA for production deploys
          TAG="sha-$(git rev-parse --short HEAD)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Using image tag: $TAG"

      - name: Parse services
        id: services
        run: |
          INPUT="${{ inputs.services }}"
          if [[ "$INPUT" == "all" || -z "$INPUT" ]]; then
            echo 'list=["simulator","gateway","auth","website","ops"]' >> $GITHUB_OUTPUT
          else
            # Convert comma-separated to JSON array
            JSON=$(echo "$INPUT" | tr ',' '\n' | jq -R . | jq -s .)
            echo "list=$JSON" >> $GITHUB_OUTPUT
          fi

      - name: Verify images exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          SERVICES=("simulator" "gateway" "auth" "website" "ops")

          for service in "${SERVICES[@]}"; do
            IMAGE="ghcr.io/${{ github.repository_owner }}/nullspace-${service}:${TAG}"
            echo "Checking: $IMAGE"

            # Verify image exists in GHCR
            if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "::warning::Image not found with tag $TAG, checking for 'latest'"
              IMAGE="ghcr.io/${{ github.repository_owner }}/nullspace-${service}:latest"
              if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
                echo "::error::Required image not found: nullspace-${service}"
                exit 1
              fi
            fi
          done
          echo "All required images verified"

  # Notify deployment start
  notify-start:
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Notify Slack - Deployment Starting
        if: vars.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"blocks\": [
                {
                  \"type\": \"header\",
                  \"text\": {
                    \"type\": \"plain_text\",
                    \"text\": \"ðŸš€ Production Deployment Starting\",
                    \"emoji\": true
                  }
                },
                {
                  \"type\": \"section\",
                  \"fields\": [
                    {\"type\": \"mrkdwn\", \"text\": \"*Environment:*\nProduction\"},
                    {\"type\": \"mrkdwn\", \"text\": \"*Triggered by:*\n${{ github.actor }}\"},
                    {\"type\": \"mrkdwn\", \"text\": \"*Image Tag:*\n${{ needs.validate.outputs.image_tag }}\"},
                    {\"type\": \"mrkdwn\", \"text\": \"*Run:*\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>\"}
                  ]
                }
              ]
            }" \
            "$SLACK_WEBHOOK_URL" || echo "Slack notification failed (non-fatal)"

  # Production deployment with manual approval
  deploy:
    runs-on: ubuntu-latest
    needs: [validate, notify-start]
    environment: production  # Requires manual approval
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install SOPS
        run: |
          curl -LO https://github.com/getsops/sops/releases/download/v3.8.1/sops-v3.8.1.linux.amd64
          sudo mv sops-v3.8.1.linux.amd64 /usr/local/bin/sops
          sudo chmod +x /usr/local/bin/sops

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.40.5/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Decrypt secrets
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY_PRODUCTION }}
        run: |
          mkdir -p /tmp/secrets
          chmod 700 /tmp/secrets
          ./scripts/decrypt-secrets.sh production /tmp/secrets

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          SSH_KNOWN_HOSTS: ${{ secrets.PRODUCTION_SSH_KNOWN_HOSTS }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Deploy services
        env:
          DEPLOY_HOST: ${{ vars.PRODUCTION_HOST }}
          DEPLOY_USER: ${{ vars.PRODUCTION_USER }}
          IMAGE_TAG: ${{ needs.validate.outputs.image_tag }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "=== Deploying to Production ==="
          echo "Host: $DEPLOY_HOST"
          echo "Image tag: $IMAGE_TAG"

          # Create deployment script
          cat > /tmp/deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -euo pipefail

          IMAGE_TAG="$1"
          GHCR_OWNER="$2"

          # Login to GHCR
          echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_OWNER" --password-stdin

          # Pull latest images
          SERVICES=("simulator" "gateway" "auth" "website" "ops")
          for service in "${SERVICES[@]}"; do
            echo "Pulling nullspace-${service}:${IMAGE_TAG}..."
            docker pull "ghcr.io/${GHCR_OWNER}/nullspace-${service}:${IMAGE_TAG}" || \
              docker pull "ghcr.io/${GHCR_OWNER}/nullspace-${service}:latest"
          done

          # Deploy in order per runbook Section 3
          echo "=== Step 1: Deploy simulator/indexer ==="
          docker compose -f /opt/nullspace/docker-compose.yml up -d simulator
          sleep 5

          echo "=== Step 2: Deploy validators ==="
          docker compose -f /opt/nullspace/docker-compose.yml up -d node
          sleep 5

          echo "=== Step 3: Deploy gateway ==="
          docker compose -f /opt/nullspace/docker-compose.yml up -d gateway
          sleep 3

          echo "=== Step 4: Deploy auth service ==="
          docker compose -f /opt/nullspace/docker-compose.yml up -d auth
          sleep 3

          echo "=== Step 5: Deploy website ==="
          docker compose -f /opt/nullspace/docker-compose.yml up -d website
          sleep 2

          echo "=== Step 6: Deploy ops service ==="
          docker compose -f /opt/nullspace/docker-compose.yml up -d ops

          echo "=== Deployment complete ==="
          docker compose -f /opt/nullspace/docker-compose.yml ps
          DEPLOY_SCRIPT

          chmod +x /tmp/deploy.sh

          # Copy secrets and deploy script to host
          scp -o StrictHostKeyChecking=no /tmp/secrets/*.env "$DEPLOY_USER@$DEPLOY_HOST:/opt/nullspace/secrets/"
          scp -o StrictHostKeyChecking=no /tmp/deploy.sh "$DEPLOY_USER@$DEPLOY_HOST:/tmp/deploy.sh"

          # Execute deployment
          ssh -o StrictHostKeyChecking=no "$DEPLOY_USER@$DEPLOY_HOST" \
            "GHCR_TOKEN='$GHCR_TOKEN' /tmp/deploy.sh '$IMAGE_TAG' '${{ github.repository_owner }}'"

      - name: Clean up secrets
        if: always()
        run: |
          rm -rf /tmp/secrets
          rm -f ~/.ssh/id_ed25519

  # Post-deployment smoke tests
  smoke-tests:
    runs-on: ubuntu-latest
    needs: deploy
    if: inputs.skip_smoke_tests != true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run smoke tests
        env:
          INDEXER_URL: ${{ vars.PRODUCTION_INDEXER_URL }}
          GATEWAY_URL: ${{ vars.PRODUCTION_GATEWAY_URL }}
          AUTH_URL: ${{ vars.PRODUCTION_AUTH_URL }}
          METRICS_TOKEN: ${{ secrets.PRODUCTION_METRICS_TOKEN }}
        run: |
          set -euo pipefail

          echo "=== Running Post-Deployment Smoke Tests ==="

          FAILED=0

          # Test 1: Indexer health
          echo "Testing indexer health..."
          if curl -sf --max-time 10 "${INDEXER_URL}/healthz" > /dev/null; then
            echo "âœ… Indexer health check passed"
          else
            echo "âŒ Indexer health check failed"
            FAILED=1
          fi

          # Test 2: Gateway health
          echo "Testing gateway health..."
          if curl -sf --max-time 10 "${GATEWAY_URL}/healthz" > /dev/null; then
            echo "âœ… Gateway health check passed"
          else
            echo "âŒ Gateway health check failed"
            FAILED=1
          fi

          # Test 3: Auth service health
          echo "Testing auth service health..."
          if curl -sf --max-time 10 "${AUTH_URL}/healthz" > /dev/null; then
            echo "âœ… Auth service health check passed"
          else
            echo "âŒ Auth service health check failed"
            FAILED=1
          fi

          # Test 4: Metrics endpoint (with auth)
          echo "Testing metrics endpoint..."
          if curl -sf --max-time 10 -H "x-metrics-token: ${METRICS_TOKEN}" \
            "${INDEXER_URL}/metrics/prometheus" | head -5 > /dev/null; then
            echo "âœ… Metrics endpoint check passed"
          else
            echo "âŒ Metrics endpoint check failed"
            FAILED=1
          fi

          # Test 5: Gateway WebSocket connectivity
          echo "Testing gateway WebSocket..."
          WS_URL=$(echo "$GATEWAY_URL" | sed 's/https:/wss:/' | sed 's/http:/ws:/')
          if timeout 5 curl -sf -o /dev/null -H "Connection: Upgrade" -H "Upgrade: websocket" \
            -H "Sec-WebSocket-Version: 13" -H "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==" \
            "${WS_URL}/"; then
            echo "âœ… WebSocket connectivity check passed"
          else
            # WebSocket upgrade may return 101, which curl treats as success
            echo "âš ï¸ WebSocket connectivity check completed (manual verification recommended)"
          fi

          echo ""
          if [[ $FAILED -eq 0 ]]; then
            echo "=== All smoke tests passed âœ… ==="
          else
            echo "=== Some smoke tests failed âŒ ==="
            exit 1
          fi

  # Notify deployment result
  notify-result:
    runs-on: ubuntu-latest
    needs: [validate, deploy, smoke-tests]
    if: always()

    steps:
      - name: Notify Slack - Deployment Result
        if: vars.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ vars.SLACK_WEBHOOK_URL }}
        run: |
          if [[ "${{ needs.smoke-tests.result }}" == "success" || "${{ needs.smoke-tests.result }}" == "skipped" ]]; then
            if [[ "${{ needs.deploy.result }}" == "success" ]]; then
              STATUS="âœ… Success"
              COLOR="good"
            else
              STATUS="âŒ Failed"
              COLOR="danger"
            fi
          else
            STATUS="âŒ Smoke Tests Failed"
            COLOR="danger"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"blocks\": [
                  {
                    \"type\": \"header\",
                    \"text\": {
                      \"type\": \"plain_text\",
                      \"text\": \"Production Deployment: $STATUS\",
                      \"emoji\": true
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"fields\": [
                      {\"type\": \"mrkdwn\", \"text\": \"*Environment:*\nProduction\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Triggered by:*\n${{ github.actor }}\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Image Tag:*\n${{ needs.validate.outputs.image_tag }}\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Duration:*\n$(date -u -d @$(($(date +%s) - ${{ github.run_started_at }})) +'%H:%M:%S' 2>/dev/null || echo 'N/A')\"}
                    ]
                  },
                  {
                    \"type\": \"actions\",
                    \"elements\": [
                      {
                        \"type\": \"button\",
                        \"text\": {\"type\": \"plain_text\", \"text\": \"View Workflow\"},
                        \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                      }
                    ]
                  }
                ]
              }]
            }" \
            "$SLACK_WEBHOOK_URL" || echo "Slack notification failed (non-fatal)"
